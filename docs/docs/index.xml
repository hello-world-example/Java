<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Java</title>
    <link>https://hello-world-example.github.io/Java/docs/</link>
    <description>Recent content in Docs on Java</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Java/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java/docs/java.lang/SecurityManager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java/docs/java.lang/SecurityManager/</guid>
      <description>SecurityManager 简单理解  JDK 针对一些敏感的资源操作，通过 Security 机制，添加了很多埋点 权限通过 配置文件 $JAVA_HOME/jre/lib/security/java.policy 进行配置 配置文件的匹配 通过 java.security.Permission 的各种子类实现 具体的校验操作 通过 java.security.AccessController.checkPermission(perm) 处理 SecurityManager 对 AccessController 进行了封装了，通过 checkXXX() 调用 SecurityManager 的获取方式一般通过 System.getSecurityManager() 获取，使用的时候一定要判空，因为 安全机制不一定开启，如果没有开启，返回值是 null  示例埋点代码 Runtime.getRuntime().exit | System.exit 退出 JVM public void exit(int status) { SecurityManager security = System.getSecurityManager(); if (security != null) { // 不允许调用 System.exit  security.checkExit(status); } Shutdown.exit(status); } System.setProperty 设置系统属性 public static String setProperty(String key, String value) { checkKey(key); SecurityManager sm = getSecurityManager(); if (sm !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java/docs/java.time/Action/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java/docs/java.time/Action/</guid>
      <description>常见操作 Date &amp;lt;-Long-&amp;gt; Instant Instant now = Instant.now(); // Date.from 1.8 新增的方法 Date date = Date.from(now); // date.toInstant() 1.8 新增的方法 Instant justNow = date.toInstant(); // 时间戳 转 Instant  Instant instant = Instant.ofEpochMilli(timestamp); // Instant 转 时间戳（ Date.from 的内部实现 ） Date date2 = new Date(now.toEpochMilli()); // 时间戳 转 Instant（ date.toInstant 的内部实现 ） final Instant now2 = Instant.ofEpochMilli(date.getTime()); Instant &amp;lt;-(ZonedDateTime)-&amp;gt; LocalDateTime // 可理解为对 时间戳 timestamp 的封装 Instant now = Instant.now(); // 转为为各个时区的时间 ZonedDateTime zonedDateTime = now.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java/docs/java.time/Core/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java/docs/java.time/Core/</guid>
      <description>关键概念   时间标准  GMT (Greenwich Mean Time) : 格林威治(Greenwich)标准时间，英国伦敦郊区的皇家 格林威治天文台 的标准时间，是太阳在 格林威治上空最高点 时的时间。因为 公转速度的不均匀 和 自转速度的减慢 ，最大误差可达 16分钟，因此格林威治时间已经不再被作为标准时间使用 UTC (Universal Time Coordinated): 协调世界时，由原子钟报时，相对与 GMT 经度更高，可认为 UTC = GMT+0，只是统计方式不同 DST (Daylight Saving Time): 夏令时，又称“日光节约时制”，是一种为节约能源而人为规定地方时间的制度。各个采用夏令时的国家规则不同，大致是在天亮早的夏季人为将时间调快一小时，以充分利用光照资源，从而节约照明用电。1986~1991年我国曾采用了6年夏时制，因为各种原因导致了很多的混乱，因此后续取消。 CST (Cxxx Standard Time): 是一个地区时间，不同地区的时间不一致  中国标准时间：China Standard Time UTC+8:00 美国中部时间：Central Standard Time UTC-6:00 澳大利亚中部时间：Central Standard Time UTC+9:30 古巴标准时间：Cuba Standard Time UTC-4:00   关键词   temporal 时间上的 temporal amount 时间量 chrono 长期的、慢性的 chronology 年表 period 时期、时代 duration 期间、持续时间 epoch 世纪   关键类  java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java/docs/java.time/Gap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java/docs/java.time/Gap/</guid>
      <description>时间区间  Period and Duration 官方文档
 继承关系 [i] java.time.temporal.TemporalAmount [c] java.time.Duration [i] java.time.chrono.ChronoPeriod [c] java.time.Period   temporal 时间上的 temporal amount 时间量 chrono 长期的、慢性的 chronology 年表 period 时期、时代 duration 期间、持续时间   Duration // 1 秒时间 final Duration seconds = Duration.of(1, ChronoUnit.SECONDS); // 1.361 秒 final Duration duration = seconds.plusMillis(361); // 获取当前时间 final LocalTime now = LocalTime.now(); // 当前时间 + 1s final LocalTime start = now.plus(seconds); // 当前时间 + 1.</description>
    </item>
    
  </channel>
</rss>